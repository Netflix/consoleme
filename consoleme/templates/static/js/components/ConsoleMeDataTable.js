import React, { Component } from 'react'
import ReactDOM from 'react-dom'
import DataTable from 'react-data-table-component'
import { Input } from 'semantic-ui-react'

// Todo: Want to have special header component for some
// Maybe generated by configuration to help us filter

function maybeParseJsonString (str) {
  try {
    return JSON.parse(str)
  } catch (e) {
    return str
  }
}

function ExpandNestedJson (data) {
  const keys = Object.keys(data)
  keys.forEach(function (item, index) {
    data[item] = maybeParseJsonString(data[item])
  })
  return JSON.stringify(data, null, 2)
}

const ExpandedComponent = ({ data }) => (
  <div>
    <pre>
      {ExpandNestedJson(data)}
    </pre>
  </div>
)

class ConsoleMeDataTable extends Component {
  constructor (props) {
    super(props)
    this.state = {
      configEndpoint: props.configEndpoint,
      data: [],
      q: '',
      loading: false,
      totalRows: 0,
      perPage: 10,
      tableConfig: {
        expandableRows: true,
        expandOnRowClicked: true,
        pagination: true,
        highlightOnHover: true,
        striped: true,
        subHeader: true,
        filterColumns: true,
        tableName: '',
        sortable: false,
        grow: 3,
        wrap: true,
        dataEndpoint: '',
        desiredColumns: []
      },
      filters: {},
      columns: []
    }
  }

  generateCell (row, item) {
    if (item.cell.type === 'href') {
      let href = item.cell.href
      let name = item.cell.name
      const hrefReplacements = href.match(/\{(.*)\}/)
      const nameReplacements = name.match(/\{(.*)\}/)
      hrefReplacements.forEach(function (item, index) {
        try {
          const matches = href.matchAll(/\{(.*?)\}/g)
          for (const match of matches) {
            href = href.replace(match[0], eval(match[1]))
          }
        } catch (e) {
        }
      })

      nameReplacements.forEach(function (item, index) {
        try {
          const matches = name.matchAll(/\{(.*?)\}/g)
          for (const match of matches) {
            name = name.replace(match[0], eval(match[1]))
          }
        } catch (e) {
        }
      })

      return <a href={href} target="_blank" rel="noopener noreferrer">{name})</a>
    }
  }

  filterColumn (event) {
    const target = event.target
    const name = target.name
    let filters = this.state.filters
    filters[name] = target.value
    this.setState({ filters: filters })
  }

  filterTable (rows) {
    let filters = this.state.filters
    console.log(filters)
    const columns = rows[0] && Object.keys(rows[0])
    return rows.filter(
      (row) => columns.some(column => row[column] && row[column].toString().toLowerCase().indexOf(this.state.q.toLowerCase()) > -1)
    )
  }

  genColumns () {
    const { tableConfig } = this.state
    let columns = []
    let filters = this.state.filters
    tableConfig.desiredColumns.forEach(function (item, index) {
      let name = item.name
      if (tableConfig.filterColumns) {
        // name = <Input name={item.name} onChange={this.filterColumn.bind(this)} placeholder={'Search ' + item.name}></Input>
        name = <Input name={item.name}
          ref = {item.name}
          placeholder={'Search ' + item.name}
          onChange={this.filterColumn.bind(this)}
          value={'' || filters[item.name]}
        >
        </Input>
      }
      let column = {
        name: name,
        selector: item.selector,
        sortable: tableConfig.sortable,
        grow: tableConfig.grow,
        wrap: tableConfig.wrap
      }

      if (item.cell) {
        // We're evaling the Cell configuration provided by ConsoleMe, and not untrusted user input.
        column.cell = row => this.generateCell(row, item)
      }

      columns.push(column)
    }.bind(this))
    return columns
  }

  async componentDidMount () {
    this.setState({ loading: true })

    // Todo: This is the only thing that needs to be passed in
    const configRequest = await fetch(this.state.configEndpoint)
    const tableConfig = await configRequest.json()
    this.setState({ tableConfig: tableConfig })

    if (tableConfig.dataEndpoint) {
      const dataRequest = await fetch(tableConfig.dataEndpoint)
      this.setState({ data: await dataRequest.json() })
    }
    this.setState({ loading: false })
  }

  render () {
    const { loading, data, tableConfig } = this.state
    const columns = this.genColumns()
    return (
      <div>
        <DataTable
          title={tableConfig.tableName}
          columns={columns}
          data={this.filterTable(data)}
          progressPending={loading}
          expandableRows={tableConfig.expandableRows}
          expandOnRowClicked={tableConfig.expandOnRowClicked}
          pagination={tableConfig.pagination}
          highlightOnHover={tableConfig.highlightOnHover}
          striped={tableConfig.striped}
          subHeader={tableConfig.subHeader}
          expandableRowsComponent={<ExpandedComponent/>}
        />
      </div>
    )
  }
}

export function renderDataTable (configEndpoint) {
  ReactDOM.render(
    <ConsoleMeDataTable configEndpoint={configEndpoint}/>,
    document.getElementById('datatable')
  )
}

export default ConsoleMeDataTable
